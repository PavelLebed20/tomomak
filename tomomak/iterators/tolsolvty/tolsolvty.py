import numpy as np
from numpy.linalg import norm, lstsq, svd


def tolsolvty(infA, supA, infb, supb, *args):
    """
    Вычисление максимума распознающего функционала допускового множества
    решений для интервальной системы линейных алгебраических уравнений.

    TOLSOLVTY(infA, supA, infb, supb) выдаёт значение максимума распознающего
    функционала допускового множества решений для интервальной системы линейных
    уравнений Ax = b, у которой матрицы нижних и верхних концов элементов A
    равны infA и supA, а векторы нижних и верхних концов правой части b  равны
    infb  и  supb  соответственно. Дополнительно  процедура  выводит  аргумент
    максимума - допусковое решение или псевдорешение интервальной линейной
    системы Ax = b, имеющее наибольшую меру разрешимости, а также  заключение
    о пустоте/непустоте допускового множества решений и диагностику работы.

    Синтаксис вызова:
        tolmax, argmax, envs, ccode = tolsolvty(infA, supA, infb, supb,
                                                iprn, weight, epsf, epsx, epsg, maxitn)

    Обязательные входные аргументы функции:
         infA, supA - матрицы левых и правых концов интервальных коэффициентов
                      при  неизвестных  для  интервальной  системы  линейных
                      алгебраических уравнений; они могут быть прямоугольными,
                      но должны иметь одинаковые размеры;
         infb, supb - векторы левых и правых концов интервалов  правой части
                      интервальной системы линейных алгебраических уравнений.

    Необязательные входные аргументы функции:
               iprn - выдача протокола работы; если iprn > 0 - информация
                      о ходе процесса печатается через каждые iprn-итераций;
                      если iprn <= 0 (значение по умолчанию), печати нет;
             weight - положительный вектор весовых коэффициентов для образующих
                      распознающего функционала, по умолчанию берётся равным
                      вектору со всеми единичными компонентами;
               epsf - допуск на точность по значению целевого функционала,
                      по умолчанию устанавливается 1.e-6;
               epsx - допуск на точность по аргументу целевого функционала,
                      по умолчанию устанавливается 1.e-6;
               epsg - допуск на малость нормы суперградиента функционала,
                      по умолчанию устанавливается 1.e-6;
             maxitn - ограничение на количество шагов алгоритма,
                      по умолчанию устанавливается 2000.

    Выходные аргументы функции:
             tolmax - значение максимума распознающего функционала;
             argmax - доставляющий его вектор значений аргумента,который
                      лежит в допусковом множестве решений при tolmax>=0;
               envs - значения образующих распознающего функционала в точке
                      его максимума, отсортированные по возрастанию;
              ccode - код завершения алгоритма (1 - по допуску epsf на
                      изменения значений функционала, 2 - по допуску epsg
                      на суперградиент, 3 - по допуску epsx на вариацию
                      аргумента, 4 - по числу итераций, 5 - не найден
                      максимум по направлению).

    Эта  программа  выполняет  исследование допускового множества решений
    для интервальной системы  линейных  алгебраических  уравнений  Ax = b
    с интервальной матрицей A = [infA, supA] и интервальным вектором правой
    части  b = [infb, supb] с помощью максимизации распознающего функционала
    допускового множества решений этой системы. См. подробности в

       Шарый С.П. Конечномерный интервальный анализ. - Новосибирск: XYZ,
       2017. - Электронная книга, доступная на http://www.nsc.ru/interval,
       параграф 6.4;
       Shary S.P. Solving the linear interval tolerance problem //
       Mathematics and Computers in Simulation. - 1995. - Vol. 39.
       - P. 53-85.

    Вектор весовых коэффициентов для образующих распознающего функционала
    (фактически, для отдельных уравнений системы) позволяет учитывать разную
    ценность отдельных уравнений, соответствующую неравноценным измерениям
    в задаче восстановления зависимостей и т.п.

    Для  максимизации  вогнутого  распознающего  функционала  используется
    вариант алгоритма суперградиентного подъёма с растяжением пространства
    в направлении  разности  последовательных суперградиентов, предложенный
    (для случая минимизации) в работе
        Шор Н.З., Журбенко Н.Г. Метод минимизации, использующий операцию
        растяжения пространства в направлении разности двух последовательных
        градинетов // Кибернетика. - 1971. - №3. - С. 51-59.

    В качестве основы этой части программы использована процедура негладкой
    оптимизации ralgb5, разработанная и реализованная П.И.Стецюком (Институт
    кибернетики НАН Украины, Киев). Подробно этот алгоритм описан в статье

        Стецюк П.И. Субградиентные методы ralgb5 и ralgb4 для минимизации
        овражных выпуклых функций // Вычислительные технологии. - 2017. -
        Т. 22, № 2. - С. 127-149.
    """

    infA = np.array(infA)
    supA = np.array(supA)
    infb = np.array(infb)
    supb = np.array(supb)
    # проверка корректности входных данных
    mi = infA.shape[0]
    ni = infA.shape[1]
    ms = supA.shape[0]
    ns = supA.shape[1]
    if mi == ms:
        m = ms
    else:
        raise ValueError('Количество строк в матрицах левых и правых концов неодинаково')

    if ni == ns:
        n = ns  # n - количество неизвестных переменных в системе
    else:
        raise ValueError('Количество столбцов в матрицах левых и правых концов неодинаково')

    ki = infb.shape[0]
    ks = supb.shape[0]
    if ki == ks:
        k = ks
    else:
        raise ValueError('Количество компонент у векторов левых и правых концов неодинаково')
    if k != m:
        raise ValueError('Размеры матрицы системы не соответствуют размерам правой части')

    if not np.all(infA <= supA):
        raise ValueError('В матрице системы задан неправильный интервальный элемент')

    if not np.all(infb <= supb):
        raise ValueError('В векторе правой части задана неправильная интервальная компонента')

    # задание параметров алгоритма суперградиентного подъёма и прочих
    maxitn = 2000        # ограничение на количество шагов алгоритма
    nsims = 30           # допустимое количество одинаковых шагов
    epsf = 1.0e-6        # допуск на изменение значения функционала
    epsx = 1.0e-6        # допуск на изменение аргумента функционала
    epsg = 1.0e-6        # допуск на норму суперградиента функционала

    alpha = 2.3          # коэффициент растяжения пространства в алгоритме
    hs = 1.0             # начальная величина шага одномерного поиска
    nh = 3               # число одинаковых шагов одномерного поиска
    q1 = 0.9             # q1, q2 - параметры адаптивной регулировки шагового множителя
    q2 = 1.1             # шагового множителя

    iprn = 0             # печать о ходе процесса через каждые iprn-итераций, (если iprn < 0, то печать подавляется)

    weight = np.ones(m)  # задание вектора весовых коэффициентов для образующих

    # формирование строковых констант для оформления протокола работы
    hor_line = '-------------------------------------------------------------'
    tit_line = 'Протокол максимизации распознающего функционала Tol'
    tab_line = 'Шаг        Tol(x)         Tol(xx)   ВычФун/шаг  ВычФун'

    # переназначение параметров алгоритма, заданных пользователем
    largs = len(args)
    if largs > 0:
        iprn = args[0]
        if largs > 1:
            weight = np.array(args[1])
            if weight.shape != tuple([m]):
                raise ValueError('Размер вектора весовых коэффициентов задан некорректно')
            if np.any(weight <= 0):
                raise ValueError('Вектор весовых коэффициентов должен быть положительным')
            if largs > 2:
                epsf = args[2]
                if largs > 3:
                    epsx = args[3]
                    if largs > 4:
                        epsg = args[4]
                        if largs > 5:
                            maxitn = args[5]

    b = 0.5 * (infb + supb)
    bh = 0.5 * (supb - infb)

    def calcfg(_x):
        """
        Функция, которая вычисляет значение f максимизируемого распознающего
        функционала и его суперградиент g;  кроме того, она выдаёт вектор tt
        из значений образующих функционала в данной точке аргумента
        """

        # предварительное размещение рабочих массивов

        mags = np.zeros(m)
        dl = np.zeros((n, m))
        ds = np.zeros((n, m))
        dd = np.zeros((n, m))

        # вычисляем значение распознающего функционала и матрицу dd,
        # составленную из суперградиентов его образующих

        x_pos = np.where(_x >= 0)[0]
        x_neg = np.where(_x < 0)[0]
        supAx = supA * _x
        infAx = infA * _x

        # нижний и верхний концы интервала, который получается под модулем
        infs = b - np.sum(supAx[:, x_pos], axis=1) - np.sum(infAx[:, x_neg], axis=1)
        sups = b - np.sum(infAx[:, x_pos], axis=1) - np.sum(supAx[:, x_neg], axis=1)

        # модуль
        ainfs = np.abs(infs)
        asups = np.abs(sups)

        # вычисление значения образующих распознающего функционала и их суперградиентов
        delta = 1.0e-6  # разная точность чисел у python и matlab
        diff = ainfs - asups
        ind1 = np.where(diff > delta)[0]
        ind2 = np.where(-diff > delta)[0]
        ind3 = np.where(np.abs(diff) <= delta)[0]
        sups_pos = np.where(sups > 0)[0]
        sups_neg = np.where(sups <= 0)[0]

        # вычисление суперградиента dl нижнего конца и суперградиента ds верхнего конца
        dl[x_neg, :] = infA[:, x_neg].T
        ds[x_neg, :] = supA[:, x_neg].T
        dl[x_pos, :] = supA[:, x_pos].T
        ds[x_pos, :] = infA[:, x_pos].T

        # сборка полного суперградиента
        dd[:, ind1] = -weight[ind1] * dl[:, ind1]
        dd[:, ind2] = weight[ind2] * ds[:, ind2]
        dd[:, sups_pos] = weight[sups_pos] * ds[:, sups_pos]
        dd[:, sups_neg] = -weight[sups_neg] * dl[:, sups_neg]

        # нахождение и запоминание значения образующих
        mags[ind1] = ainfs[ind1]
        mags[ind2] = asups[ind2]
        mags[ind3] = ainfs[ind3]
        _tt = weight * (bh - mags)

        # выбираем минимальную по значению образующую
        # и конструируем общий суперградиент
        mc = np.argmin(_tt)
        return _tt[mc], dd[:, mc], _tt

    """
    формируем начальное приближение x как решение либо псевдорешение 
    'средней' точечной системы, если она не слишком плохо обусловлена,
    иначе берём начальным приближением нулевой вектор 
    """
    Ac = 0.5 * (infA + supA)
    bc = b
    sv = svd(Ac, compute_uv=False)
    minsv = min(sv)
    maxsv = max(sv)

    if minsv != 0 and maxsv / minsv < 1.0e+15:
        x = lstsq(Ac, bc)[0]
    else:
        x = np.zeros(n)

    """
    Рабочие массивы:
        B - матрица обратного преобразования пространства
        vf - вектор приращений функционала на последних шагах алгоритма
        g, g0, g1 - используются для хранения вспомогательных векторов,
           суперградиента минимизируемого функционала и др.
    """
    B = np.eye(n)                 # инициализируем единичной матрицей
    vf = np.full(nsims, np.inf)   # инициализируем самыми большими числами

    # установка начальных параметров

    w = 1.0 / alpha - 1.0
    lp = iprn

    f, g0, tt = calcfg(x)
    ff = f
    xx = x
    cal = 1
    ncals = 1

    if iprn > 0:
        print('\t%52s' % tit_line)
        print('%65s' % hor_line)
        print('\t%50s' % tab_line)
        print('%65s' % hor_line)
        print('\t%d\t%f\t%f\t%d\t%d' % (0, f, ff, cal, ncals))

    """
    основной цикл программы:
        itn - счётчик числа итераций
        xx  - приближение к аргументу максимума функционала
        ff  - приближение к максимуму функционала 
        cal - количество вычислений функционала на текущем шаге 
      ncals - общее количество вычислений целевого функционала
    """
    itn = 1
    ccode = 4
    while itn <= maxitn:
        vf[nsims - 1] = ff
        # критерий останова по норме суперградиента
        if norm(g0, 2) < epsg:
            ccode = 2
            break

        # вычисляем суперградиент в преобразованном пространстве, определяем направление подъёма
        g1 = B.T.dot(g0)
        g = B.dot(g1) / norm(g1, 2)
        normg = norm(g, 2)
        """
        одномерный подъём по направлению g:
            cal - счётчик шагов одномерного поиска,
            deltax - вариация аргумента в процессе поиска
        """
        r = 1
        cal = 0
        deltax = 0
        while r > 0 and cal <= 500:
            cal += 1
            x += hs * g
            deltax += hs * normg
            f, g1, tt = calcfg(x)
            if f > ff:
                ff = f
                xx = x
            # если прошло nh шагов одномерного подъёма, то увеличиваем величину шага hs
            if cal % nh == 0:
                hs *= q2
            r = np.dot(g, g1)

        # если превышен лимит числа шагов одномерного подъёма, то выход
        if cal > 500:
            ccode = 5
            break
        # если одномерный подъём занял один шаг, то уменьшаем величину шага hs
        if cal == 1:
            hs *= q1
        # уточняем статистику и при необходимости выводим её
        ncals += cal
        if itn == lp:
            print('\t%d\t%f\t%f\t%d\t%d' % (itn, f, ff, cal, ncals))
            lp += iprn
        # если вариация аргумента в одномерном поиске мала, то выход
        if deltax < epsx:
            ccode = 3
            break

        # пересчитываем матрицу преобразования пространства
        dg = B.T.dot(g1 - g0)
        xi = np.expand_dims(dg / norm(dg), axis=-1)
        B += w * B.dot(xi).dot(xi.T)
        g0 = g1
        # проверка изменения значения функционала, относительного либо абсолютного, на последних nsims шагах алгоритма
        vf = np.roll(vf, 1)
        vf[0] = abs(ff - vf[0])
        if abs(ff) > 1:
            deltaf = sum(vf) / abs(ff)
        else:
            deltaf = sum(vf)
        if deltaf < epsf:
            ccode = 1
            break
        ccode = 4
        itn += 1

    tolmax = ff
    argmax = xx

    # сортируем образующие распознающего функционала по возрастанию
    tt = np.vstack((np.arange(tt.shape[0]), tt))
    ind = np.argsort(tt[1])
    envs = tt[:, ind]

    # вывод результатов работы
    if iprn > 0:
        if itn % iprn != 0:
            print('\t%d\t%f\t%f\t%d\t%d' % (itn, f, ff, cal, ncals))
        print('%65s' % hor_line)

    if tolmax >= 0:
        print('Допусковое множество решений интервальной линейной системы непусто')
    else:
        print('Допусковое множество решений интервальной линейной системы пусто')

    if tolmax < 0. and abs(tolmax/epsf) < 10:
        print('Абсолютное значение вычисленного максимума находится в пределах заданной точности')
        print('Перезапустите программу с меньшими значениями epsf и/или epsx')
        print('для получения большей информации о разрешимости рассматриваемой задачи о допусках')

    return tolmax, argmax, envs, ccode
